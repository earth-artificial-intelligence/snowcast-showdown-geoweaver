[{
  "history_id" : "p5v2dntiuj0",
  "history_input" : "import os\nos.environ[\"KMP_DUPLICATE_LIB_OK\"] = \"TRUE\"\nfrom datetime import datetime, timedelta\nimport numpy as np\nfrom models_init import Model0\nimport os\nimport torch\n# import features_init as features\n\nsind = lambda x: np.sin(np.radians(x))\ncosd = lambda x: np.cos(np.radians(x))\ndef sundirect(data,lat,lon):\n    D = data-datetime(2000,1,1)\n    D = 2.*np.pi/365.242*(D.days+D.seconds/86400.)\n    D = 0.39785*np.sin(D+np.radians(279.9348+1.9148*np.sin(D)-0.0795*np.cos(D)+0.0199*np.sin(D+D)-0.0016*np.cos(D+D)))\n    D = np.sqrt(1.-D*D)+D*sind(lat)-1.\n    cfi = cosd(lat)\n    return {'CRayMin':D-cfi, 'CRayMax':D+cfi, 'SinYear':sind(lat)}\ndef printshape(a, prefix='', print=print):\n    print (prefix+str({key: (a[key].dtype,a[key].shape,torch.isfinite(a[key]).sum().item() if isinstance(a[key],torch.Tensor) else np.isfinite(a[key]).sum()) for key in a} \\\n           if isinstance(a,dict) else [(x.dtype,x.shape,torch.isfinite(x).sum().item() if isinstance(x,torch.Tensor) else np.isfinite(x).sum()) for x in a]))\n\ndef getdatadict(rmode, stswe, gridswe, constfeatures, rsfeatures, maindevice, withpred=True, nmonths=1, print=print):\n    # shifts = [1,2,4]\n    shifts = [1,2,3,4]\n    print ('getdatadict: '+(f'Withpred shifts: {shifts}' if withpred else 'Withoutpred'))\n    if nmonths == 1:\n        monthid = {1:0, 2:0, 3:0, 4:0, 5:0, 6:0, 12:0}\n    elif nmonths == 2:\n        monthid = {1:0, 2:0, 3:1, 4:1, 5:1, 6:1, 12:0}\n    elif nmonths == 3:\n        monthid = {1:0, 2:0, 3:1, 4:1, 5:2, 6:2, 12:0}\n    elif nmonths == 6:\n        monthid = {1:0, 2:1, 3:2, 4:3, 5:4, 6:5, 12:6}    \n    Model0m = Model0.to(maindevice)\n    def apply0 (inputs, rmax=1., valid_bs=64):\n        sh = inputs['ylo' if 'ylo' in inputs else 'xlo'].shape\n        result = torch.zeros(sh+(inputs['xval'].shape[-1],), device=maindevice)\n        batches = int(np.ceil(inputs['xlo'].shape[0]/valid_bs))    \n        with torch.no_grad():\n            for i in range (batches):\n                sel = torch.arange(i*valid_bs, min((i+1)*valid_bs,inputs['xlo'].shape[0]), device=maindevice)\n                result[sel] = Model0m ({key: inputs[key][sel] for key in inputs})\n        return result\n    days = {mode: features.getdays(stswe[mode]) for mode in stswe}    \n    # if 'train' in days:\n    #     days['train'] = [d for d in days['train'] if int(d[5:7])<=7]\n    dates = {mode: [datetime.strptime(tday,'%Y-%m-%d') for tday in days[mode]] for mode in stswe}\n    inputs = {mode: {} for mode in stswe}    \n    for mode in stswe:\n        for tday,date in zip(days[mode], dates[mode]):\n            arg = {}\n            for lab,d in zip('xy',[stswe, gridswe]):\n                if tday in d[mode]:\n                    val = [d[mode][tday].values]\n                    if withpred:\n                        pred = []\n                        for dt in shifts:\n                        # for dt in [1]:\n                            tday1 = (date-timedelta(days=7*dt)).strftime('%Y-%m-%d')\n                            pred.append(d[mode][tday1].values if tday1 in d[mode] else val[0])\n                            bad = np.isnan(pred[-1])                            \n                            pred[-1][bad] = val[0][bad] if dt == 1 else pred[-2][bad]\n                        pred.reverse()\n                        val += pred\n                    arg.update({lab+'val': np.hstack([v[:,None] for v in val])})\n                arg.update({lab+'lo': d[mode]['longitude'].values, lab+'la': d[mode]['latitude'].values, \n                            lab+'emb': d[mode]['emb'].values*nmonths+monthid[date.month]})\n                s = sundirect(date, arg[lab+'la'], arg[lab+'lo'])\n                arg[lab+'input'] = np.hstack( [d[mode][key].values[:,None] for key in constfeatures]+\n                        [s[key][:,None] for key in s]+\n                        [d[mode][tday+key].values[:,None] if tday+key in d[mode] else np.full((d[mode].shape[0],1),np.nan) for key in rsfeatures]\n                       )\n                arglist = constfeatures + list(s.keys()) + rsfeatures\n            for key in arg:\n                if key not in inputs[mode]:\n                    inputs[mode][key] = []\n                inputs[mode][key].append(arg[key][None])\n        for key in inputs[mode]:\n            x = np.vstack(inputs[mode][key])\n            inputs[mode][key] = torch.tensor(x if key[1:] in ['lo', 'la', 'emb'] or x.ndim==3 else x[:,:,None], device=maindevice, \n                                             dtype=torch.long if key[1:]=='emb' else torch.float32)\n        if mode == 'train' or rmode not in ['oper']:\n            inputs[mode]['target'] = inputs[mode]['yval' if 'yval' in inputs[mode] else 'xval'][...,:1]         \n    print(arglist)\n    # xtoy = torch.tensor(np.array([a in ['CDEC','SNOTEL'] for a in arglist]),device=maindevice)\n    # ytox = torch.tensor(np.array([a in uregions for a in arglist]),device=maindevice)\n    with torch.no_grad():\n        for mode in inputs:\n            printshape(inputs[mode], prefix=mode+': ', print=print)\n            if rmode == 'oper':\n                x = {key: inputs[mode][key] for key in inputs[mode] if key[1:] in ['lo','la']}\n                xx = {'x'+key: torch.cat((x['y'+key],x['x'+key]),1).detach() for key in ['lo','la']}\n                for i, a in enumerate(arglist):\n                    res1 = torch.cat((inputs[mode]['xinput'][...,i],inputs[mode]['yinput'][...,i]),1).detach()\n                    bad = torch.isnan (res1)\n                    ok = ~bad\n                    if ((bad.sum(1)>0) & (ok.sum(1)>0)).any():\n                        xx ['xval'] = res1[...,None].clone()\n                        xy = {key: xx[key][:,ok.any(0)] for key in xx}\n                        bad1 = bad.any(0)\n                        xy.update ({'y'+key[1:]: xx[key][:,bad1] for key in xx})\n                        print(f\"{a}: ok={ok.sum().item()} bad={bad.sum().item()}\")\n                        # printshape(xy, print=print)\n                        res2 = res1[:,bad1]\n                        res2[bad[:,bad1]] = apply0 (xy)[...,0][bad[:,bad1]]\n                        inputs[mode]['xinput'][...,i] = res1[:,:x['xlo'].shape[1]]\n                        inputs[mode]['yinput'][...,i] = res1[:,x['xlo'].shape[1]:]\n            # if xtoy.sum()>0:\n            #         x = {key: inputs[mode][key] for key in inputs[mode] if key[1:] in ['lo','la']}\n            #         x['xval'] = inputs[mode]['xinput'][..., xtoy]\n            #         # x['xval'][torch.isnan(x['xval']).any(-1)] = np.nan\n            #         inputs[mode]['yinput'][..., xtoy] = apply0 (x)\n            # if ytox.sum()>0:\n            #         x = {key: inputs[mode][('y' if key[0]=='x' else 'x')+key[1:]] for key in inputs[mode] if key[1:] in ['lo','la']}\n            #         x['xval'] = inputs[mode]['yinput'][..., ytox]\n            #         # x['xval'][torch.isnan(x['xval']).any(-1)] = np.nan\n            #         inputs[mode]['xinput'][..., ytox] = apply0 (x)\n    if 'train' in inputs:\n        inputs['train']['istrainy'] = torch.isfinite(inputs['train']['yval'][...,0]).sum(0) > 0\n        for key in inputs['train']:\n            if key[0] == 'y' or key == 'target':\n                inputs['train'][key] = inputs['train'][key][:,inputs['train']['istrainy']]\n    print(\"getdatadict finish\")\n    return inputs, arglist, days, dates",
  "history_output" : "",
  "history_begin_time" : 1668624360915,
  "history_end_time" : 1668624364803,
  "history_notes" : null,
  "history_process" : "z7yrof",
  "host_id" : "100001",
  "indicator" : "Done"
},]
