[{
  "history_id" : "hw7c14lbcrn",
  "history_input" : "import numpy as np\nfrom os import path\nimport matplotlib.pyplot as plt\nimport torch\nimport models\n\nmeannan = lambda x,dim=1: torch.nan_to_num(x,0.).sum(dim)/torch.isfinite(x).sum(dim)\ndef temporal(inputs, dates, results, result, uregions, figdir):\n    mon = np.array([d.month for d in dates])\n    ticks = [dates[i] for i in (np.nonzero(mon[1:]>mon[:-1])[0]+1)]\n    tickslabel = [d.strftime('%Y-%m-%D') for d in ticks]\n    for snotonly in [True, False]:\n        for ireg,reg in enumerate(uregions+['others', 'all']):\n            if reg in uregions:\n                region = inputs['yinput'][0,:,ireg]>0.5\n            elif reg == 'others':\n                region = inputs['yinput'][0,:,:2].sum(-1)<0.5\n            else:\n                region = torch.full(inputs['yinput'].shape[1:2], True)\n            if snotonly:\n                ok = torch.isfinite(inputs['target']).all(0)[:,0]&region\n            else:\n                ok = region\n            print(reg+(' SNOTEL' if snotonly else ' ALL')+f' count={ok.sum().item()}')\n            trg = inputs['target'][:,ok]\n            e  = results[:,ok]-trg\n            em = result[:,ok]-trg[...,0]\n            e = torch.sqrt(meannan(e*e))\n            fig, ax = plt.subplots(1,1)\n            ax.set_title(reg+(f' {ok.sum().item()} locations' if snotonly else ''))\n            ax.errorbar(dates, e.mean(-1).numpy(), e.std(-1).numpy(), label='one model error')\n            ax.plot(dates, torch.sqrt(meannan(em*em)).numpy(), '--', label='mixed model error')\n            ax.legend(loc='lower left')\n            ax2 = ax.twinx()\n            ax2.plot(dates, meannan(trg).numpy(), '-g', label='mean SWE (right axis)')\n            ax2.legend(loc='upper right')\n            ax.set_xticks(ticks)\n            ax.set_xticklabels(tickslabel)\n            fig.savefig(path.join(figdir,'Errors'+('_SNOTEL' if snotonly else '_ALL')+reg+'.png'), dpi=300)\n\nimport cartopy.crs as ccrs \nimport cartopy.feature as cfeature \nfrom cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER\nfrom matplotlib import ticker, cm, colors\nresoln = '10m'\nocean = cfeature.NaturalEarthFeature('physical', 'ocean', scale=resoln, edgecolor='none', facecolor=cfeature.COLORS['water'])\n# land = cfeature.NaturalEarthFeature('physical', 'land', scale=resoln, edgecolor='k', facecolor=cfeature.COLORS['land'])\nlakes = cfeature.NaturalEarthFeature('physical', 'lakes', scale=resoln, edgecolor='b', facecolor=cfeature.COLORS['water'])\nrivers = cfeature.NaturalEarthFeature('physical', 'rivers_lake_centerlines', scale=resoln, edgecolor='b', facecolor='none')\ncountry_borders = cfeature.NaturalEarthFeature(category='cultural', name='admin_0_boundary_lines_land', scale=resoln, facecolor='none', edgecolor='k')\nprovinc_borders = cfeature.NaturalEarthFeature(category='cultural', name='admin_1_states_provinces_lines', scale=resoln, facecolor='none', edgecolor='k')\ncrs = ccrs.PlateCarree()\ndef back (lon1=-124, lon2=-104, lat1=32, lat2=50, grid=True):\n    fig = plt.figure (figsize=(10, 10), edgecolor='w') \n    proj = ccrs.Stereographic (central_longitude=(lon1+lon2)*0.5, central_latitude=(lat1+lat2)*0.5)\n    ax = fig.add_subplot (1, 1, 1, projection=proj)\n    ax.set_extent ([lon1, lon2, lat1, lat2], crs=crs)\n    ax.add_feature (ocean, linewidth=2., edgecolor='b', facecolor='none', zorder=14)\n    ax.add_feature (lakes, linewidth=1., edgecolor='b', facecolor='b', zorder=14)\n    ax.add_feature (rivers, linewidth=1., edgecolor='b', facecolor='none', zorder=14)\n    ax.add_feature (country_borders, linewidth=2., edgecolor='k', facecolor='none', zorder=14)\n    ax.add_feature (provinc_borders, linewidth=1., edgecolor='k', facecolor='none', zorder=14)\n    if grid:\n        gl = ax.gridlines (draw_labels=True, dms=True, x_inline=False, y_inline=False)\n        gl.xlabels_top = False\n        gl.ylabels_left = True\n        gl.ylabels_right = False\n        gl.xlines = True\n        gl.xformatter = LONGITUDE_FORMATTER\n        gl.yformatter = LATITUDE_FORMATTER\n        gl.xlabel_style = gl.ylabel_style = {'size': 15, 'color': 'gray'}\n        gl.xlabel_style = gl.ylabel_style = {'color': 'k', 'weight': 'bold'}\n    return fig, ax\n\ndef spatial(inputs, dates, result, figdir):\n    snot = torch.isfinite(inputs['target']).all(0)[:,0]\n    em = result[:,snot]-inputs['target'][:,snot,0]\n    lon = inputs['ylo'][0,snot].numpy()\n    lat = inputs['yla'][0,snot].numpy()\n        \n    for mon in range(6):            \n        fig,ax = back ()\n        bounds = np.arange(0.2,5.,0.2)\n        cmap = cm.get_cmap ('viridis')\n        norm = colors.BoundaryNorm (bounds, cmap.N)\n        emm = em[torch.tensor([d.month-1==mon for d in dates])]\n        emm = torch.sqrt(meannan(emm*emm,0)).numpy()\n        img = ax.scatter(lon, lat, c=emm, cmap=cmap, norm=norm, transform=crs)\n        plt.colorbar (img, fraction=0.017, pad=0.04, ticks=bounds[4::5])\n        tit = ['January','February','March','April','May','June','July'][mon]\n        ax.set_title (tit)#+f\" mean RMSE={(emm*emm).mean():.3}\")\n        fig.savefig(path.join(figdir,tit+'.png'), dpi=300)\n\ndef importance(inputs, dates, modelslist, result, arglist, nousest, figdir):\n     groups = {'region': lambda a: a in ['central rockies', 'sierras', 'CDEC'],\n               'LandCover': lambda a: a[:9]=='GLOBCOVER',\n               'soil': lambda a: a[:4]=='SOIL',\n               'aspect': lambda a: a[:4] in ['aspe', 'east', 'sout'],\n               'elevation': lambda a: a[:9]=='elevation',\n               'MODIS': lambda a: a[:16]=='MNDSI_Snow_Cover',\n               'regular': lambda a: a in ['isemb']}\n     ret = {}\n     def permutei (x, iperm):\n         xperm = torch.randperm(x[...,0].numel())\n         xin = x.clone()\n         xin[..., iperm] = xin[..., iperm].reshape(xperm.shape[0],-1)[xperm].reshape(*x.shape[:2], -1)\n         return xin\n     for f in groups:\n         iperm = torch.tensor ([groups[f](a) for a in arglist])\n         inp = {key: permutei (inputs[key], iperm) if key[1:] == 'input' \n                 else inputs[key] for key in inputs}\n         ret[f] = models.inference (inp, modelslist, dates, lab=f, print=print, nousest=nousest)\n     e0 = result-inputs['target'][:,:,0]\n     e0 = torch.sqrt(meannan((e0*e0).reshape(-1),0))\n     imp = {}\n     for f in groups:\n         e = ret[f]-inputs['target'][:,:,0]\n         e = torch.sqrt(meannan((e*e).reshape(-1),0))\n         imp[f] = (e-e0).item()\n     order = np.argsort([imp[f] for f in imp])[::-1]        \n     keys = list(imp.keys())\n     fig, ax = plt.subplots(1,1)\n     ax.bar(['regular' if keys[o]=='ASO' else keys[o] for o in order], [imp[keys[o]] for o in order])\n     fig.savefig(path.join(figdir,'Importance.png'), dpi=200)\n\ndef latentsd(inputs, days, k, model, figdir):\n    x = {key: inputs[key][k:k+1].detach().to(models.calcdevice) for key in inputs if key[0] != 'i'}\n    res,sd = model(x)\n    \n    val,vec=torch.eig((x['ymap'][0,:,:,None]*x['ymap'][0,:,None]).sum(0), eigenvectors=True)\n    cv = {lab: (x[lab+'map'][0]*vec[:,0]).sum(-1).detach().cpu().numpy() for lab in 'xy'}\n    \n    cmap = cm.get_cmap ('viridis')\n    for loc in ['', '_CA']:\n        for visual in ['Spread', 'Latent']:\n            if loc == '_CA':\n                fig,ax = back (-122, -118, 36, 40.5)\n            else:\n                fig,ax = back ()\n            if visual == 'Spread':\n                bounds = np.arange(0.4,5.,0.2)*10.                \n                norm = colors.BoundaryNorm (bounds, cmap.N)\n                for lab in 'xy':\n                    img = ax.scatter(x[lab+'lo'][0].cpu().numpy(), x[lab+'la'][0].cpu().numpy(),\n                                      c=10.*x[lab+'sigma'][0,:,0].detach().cpu().numpy(), cmap=cmap, norm=norm, transform=crs)\n                plt.colorbar (img, fraction=0.017, pad=0.04, ticks=bounds[3::5])\n            elif visual == 'Latent':\n                bounds = np.arange(0.,56.)\n                norm = colors.BoundaryNorm (bounds, cmap.N)\n                for lab in 'xy':\n                    img = ax.scatter(x[lab+'lo'][0].cpu().numpy(), x[lab+'la'][0].cpu().numpy(),\n                                      c=cv[lab]-cv['y'].min(), cmap=cmap, norm=norm, transform=crs)\n                plt.colorbar (img, fraction=0.017, pad=0.04, ticks=bounds[::5])\n            ax.set_title (f\"{visual} {days[k]}\")\n            fig.savefig(path.join(figdir,f'{visual} {days[k]}{loc}.png'), dpi=300)\n            ",
  "history_output" : "Traceback (most recent call last):\n  File \"visualization_figures.py\", line 5, in <module>\n    import models\nModuleNotFoundError: No module named 'models'\n",
  "history_begin_time" : 1668624353429,
  "history_end_time" : 1668624356647,
  "history_notes" : null,
  "history_process" : "ro3cv8",
  "host_id" : "100001",
  "indicator" : "Failed"
},]
